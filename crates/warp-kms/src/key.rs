//! Key types and metadata

// Allow unused_assignments warnings caused by ZeroizeOnDrop derive
#![allow(unused_assignments)]

use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use zeroize::{Zeroize, ZeroizeOnDrop};

/// Encryption algorithm for keys
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum KeyAlgorithm {
    /// AES-256-GCM (default)
    #[default]
    Aes256Gcm,
    /// ChaCha20-Poly1305
    ChaCha20Poly1305,
}

impl KeyAlgorithm {
    /// Get the key size in bytes for this algorithm
    pub fn key_size(&self) -> usize {
        match self {
            KeyAlgorithm::Aes256Gcm => 32,        // 256 bits
            KeyAlgorithm::ChaCha20Poly1305 => 32, // 256 bits
        }
    }

    /// Get the nonce size in bytes for this algorithm
    pub fn nonce_size(&self) -> usize {
        match self {
            KeyAlgorithm::Aes256Gcm => 12,        // 96 bits
            KeyAlgorithm::ChaCha20Poly1305 => 12, // 96 bits
        }
    }

    /// Get the tag size in bytes for this algorithm
    pub fn tag_size(&self) -> usize {
        16 // Both algorithms use 128-bit tags
    }
}

/// Key state for lifecycle management
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum KeyState {
    /// Key is enabled and can be used
    #[default]
    Enabled,
    /// Key is disabled and cannot be used
    Disabled,
    /// Key is pending deletion
    PendingDeletion,
    /// Key has been deleted
    Deleted,
}

/// Key usage type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum KeyUsage {
    /// Key can be used for encryption and decryption
    #[default]
    EncryptDecrypt,
    /// Key can be used for signing and verification
    SignVerify,
    /// Key can be used to generate data keys
    GenerateDataKey,
}

/// Key origin type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, Default)]
pub enum KeyOrigin {
    /// Key was generated by KMS
    #[default]
    KmsGenerated,
    /// Key was imported
    External,
    /// Key is managed by AWS KMS
    AwsKms,
}

/// Metadata for a master key
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyMetadata {
    /// Unique key identifier
    pub key_id: String,

    /// Human-readable key alias
    pub alias: String,

    /// Current key version
    pub version: u32,

    /// Key state
    pub state: KeyState,

    /// Key algorithm
    pub algorithm: KeyAlgorithm,

    /// Key usage
    pub usage: KeyUsage,

    /// Key origin
    pub origin: KeyOrigin,

    /// Creation timestamp
    pub created_at: DateTime<Utc>,

    /// Last rotation timestamp
    pub last_rotated_at: Option<DateTime<Utc>>,

    /// Scheduled deletion time (if pending deletion)
    pub deletion_date: Option<DateTime<Utc>>,

    /// Optional description
    pub description: Option<String>,

    /// Tags for the key
    pub tags: Vec<(String, String)>,
}

impl KeyMetadata {
    /// Create new key metadata
    pub fn new(key_id: String, alias: String, algorithm: KeyAlgorithm) -> Self {
        Self {
            key_id,
            alias,
            version: 1,
            state: KeyState::Enabled,
            algorithm,
            usage: KeyUsage::EncryptDecrypt,
            origin: KeyOrigin::KmsGenerated,
            created_at: Utc::now(),
            last_rotated_at: None,
            deletion_date: None,
            description: None,
            tags: Vec::new(),
        }
    }

    /// Check if the key is usable
    pub fn is_usable(&self) -> bool {
        self.state == KeyState::Enabled
    }
}

/// A master key with its material
#[derive(Clone, Zeroize, ZeroizeOnDrop)]
pub struct MasterKey {
    /// Key ID
    #[zeroize(skip)]
    pub key_id: String,

    /// Key version
    #[zeroize(skip)]
    pub version: u32,

    /// Key material (secret)
    pub material: Vec<u8>,

    /// Algorithm
    #[zeroize(skip)]
    pub algorithm: KeyAlgorithm,
}

impl MasterKey {
    /// Create a new master key
    pub fn new(key_id: String, version: u32, material: Vec<u8>, algorithm: KeyAlgorithm) -> Self {
        Self {
            key_id,
            version,
            material,
            algorithm,
        }
    }

    /// Get the key material
    pub fn material(&self) -> &[u8] {
        &self.material
    }
}

impl std::fmt::Debug for MasterKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("MasterKey")
            .field("key_id", &self.key_id)
            .field("version", &self.version)
            .field("material", &"[REDACTED]")
            .field("algorithm", &self.algorithm)
            .finish()
    }
}

/// A data key for envelope encryption
#[derive(Clone, Zeroize, ZeroizeOnDrop)]
pub struct DataKey {
    /// Plaintext key material (used for encryption)
    pub plaintext: Vec<u8>,

    /// Ciphertext (encrypted by master key, stored with data)
    #[zeroize(skip)]
    pub ciphertext: Vec<u8>,

    /// Algorithm
    #[zeroize(skip)]
    pub algorithm: KeyAlgorithm,

    /// Master key ID that encrypted this data key
    #[zeroize(skip)]
    pub master_key_id: String,

    /// Master key version
    #[zeroize(skip)]
    pub master_key_version: u32,
}

impl DataKey {
    /// Create a new data key
    pub fn new(
        plaintext: Vec<u8>,
        ciphertext: Vec<u8>,
        algorithm: KeyAlgorithm,
        master_key_id: String,
        master_key_version: u32,
    ) -> Self {
        Self {
            plaintext,
            ciphertext,
            algorithm,
            master_key_id,
            master_key_version,
        }
    }

    /// Get the plaintext key material
    pub fn plaintext(&self) -> &[u8] {
        &self.plaintext
    }

    /// Get the ciphertext for storage
    pub fn ciphertext(&self) -> &[u8] {
        &self.ciphertext
    }
}

impl std::fmt::Debug for DataKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("DataKey")
            .field("plaintext", &"[REDACTED]")
            .field("ciphertext_len", &self.ciphertext.len())
            .field("algorithm", &self.algorithm)
            .field("master_key_id", &self.master_key_id)
            .field("master_key_version", &self.master_key_version)
            .finish()
    }
}

/// Key version information for rotation tracking
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct KeyVersion {
    /// Version number
    pub version: u32,

    /// Creation timestamp
    pub created_at: DateTime<Utc>,

    /// Whether this is the primary (current) version
    pub is_primary: bool,
}
